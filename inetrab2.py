# -*- coding: utf-8 -*-
"""INEtrab2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SAKaSstzGxzTcZQDCPOiMP6ZHyexxblb
"""

!pip install --upgrade xlrd

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.neighbors import NearestNeighbors
import urllib.request

from sklearn import preprocessing
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import KFold
from sklearn.model_selection import cross_val_score
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score

import sklearn.model_selection as ms
from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler

"""**Lendo arquivo**"""

url = "https://archive.ics.uci.edu/ml/machine-learning-databases/00192/BreastTissue.xls"


with urllib.request.urlopen(url) as response:
    htmlSource = response.read()

df = pd.read_excel(io=htmlSource,sheet_name='Data')

"""**Excluindo coluna que nao sera utilizada**"""

df.drop(['Case #'],1,inplace=True)
df.head()

"""**Analisando dados**"""

#tipos de atributos alvos
df['Class'].unique()

#verificando se existem valores nulos
df.isnull().values.any()

"""**Transformando coluna class para int**"""

df['Class'] = df['Class'].map({'car' :0, 'fad' :1, 'mas' :2, 'gla' :3, 'con': 4, 'adi' :5 }).astype(int)

df.head()

"""**Verificando o tipo dos dados**"""

df.info()

"""**Grafico de correlacao de atributos**"""

sns.set_style("whitegrid")
sns.pairplot(df, hue="Class", height=6)
plt.show()

x=np.array(df.drop(['Class'],1))
y=np.array(df['Class'])

"""**Normalizando dados**"""

MinMaxScaler = preprocessing.MinMaxScaler()
X_data_minmax = MinMaxScaler.fit_transform(x)
data = pd.DataFrame(X_data_minmax,columns=['I0','PA500','HFS','DA','Area','A/DA','Max IP','DR','P'])
data.head()

"""**Treinos e testes**"""

X_treino, X_teste, y_treino, y_teste = train_test_split(data, y,test_size=0.2, random_state = 10)

knn_clf=KNeighborsClassifier(n_neighbors=5)

knn_clf.fit(X_treino,y_treino)

kfold = KFold(n_splits=5,random_state=10,shuffle=True)

predict=cross_val_score(knn_clf,data,y,cv=kfold,scoring='accuracy')

predict.mean()

"""**Gerando matriz de confusao e relatorio**"""

predict2=knn_clf.predict(X_teste)
resultado = confusion_matrix(y_teste, predict2)
print("Matriz de confusao:")
print(resultado)
resultado2 = classification_report(y_teste, predict2)
print("\nRelatorio:",)
print (resultado2)
resultado3 = accuracy_score(y_teste,predict2)
print("accuracy:",resultado3)

"""**SVM**

**Treinando modelo**
"""

classifier = SVC(kernel='linear')
classifier.fit(X_treino, y_treino)

"""**Previsao**"""

kfold = KFold(n_splits=5,random_state=10,shuffle=True)

predict3=cross_val_score(classifier,data,y,cv=kfold,scoring='accuracy')

predict3.mean()

"""**Matriz de confusao**"""

y_pred = classifier.predict(X_teste)
cm = confusion_matrix(y_teste, y_pred)
print("Matriz de confusao:")
print(cm)
print("\nAccuracy:", accuracy_score(y_teste, y_pred))